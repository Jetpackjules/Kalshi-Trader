<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kalshi Ops Console</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=IBM+Plex+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        :root {
            --bg: #f6efe6;
            --bg-strong: #efe5d7;
            --panel: #fffaf3;
            --ink: #1f1c18;
            --muted: #6f6257;
            --accent: #2a6f5f;
            --accent-strong: #1d5749;
            --accent-warm: #d46a3b;
            --accent-warm-strong: #b35128;
            --grid: #e7dccd;
            --shadow: 0 18px 40px rgba(31, 28, 24, 0.12);
            --mono: "IBM Plex Mono", ui-monospace, monospace;
            --display: "Space Grotesk", ui-sans-serif, sans-serif;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: var(--display);
            color: var(--ink);
            background: radial-gradient(circle at 15% 20%, #fff7ea 0%, #f6efe6 45%, #efe5d7 100%);
        }

        .page {
            max-width: 1400px;
            margin: 0 auto;
            padding: 32px 24px 40px;
            position: relative;
        }

        .hero {
            display: flex;
            flex-wrap: wrap;
            gap: 24px;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 28px;
        }

        .hero h1 {
            font-size: clamp(28px, 4vw, 42px);
            letter-spacing: -0.02em;
            margin: 0 0 8px;
        }

        .hero p {
            margin: 0;
            color: var(--muted);
            font-size: 15px;
            max-width: 520px;
        }

        .hero-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: flex-end;
        }

        .chip {
            background: var(--panel);
            border: 1px solid var(--grid);
            padding: 8px 12px;
            border-radius: 999px;
            font-size: 12px;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            display: inline-flex;
            gap: 6px;
            align-items: center;
            box-shadow: 0 6px 16px rgba(31, 28, 24, 0.08);
        }

        .chip strong {
            font-weight: 600;
        }

        .chip a {
            text-decoration: none;
            color: inherit;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #9b9084;
            display: inline-block;
        }

        .status-running {
            background: var(--accent);
        }

        .status-paused {
            background: var(--accent-warm);
        }

        .status-stopped {
            background: #b24a42;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 22px;
        }

        .panel {
            background: var(--panel);
            border: 1px solid var(--grid);
            border-radius: 18px;
            padding: 20px 22px;
            box-shadow: var(--shadow);
        }

        .panel-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 12px;
        }

        .panel-header h2 {
            margin: 0;
            font-size: 18px;
            letter-spacing: 0.01em;
        }

        .panel-header small {
            color: var(--muted);
        }

        .panel-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .btn {
            border: none;
            background: var(--accent);
            color: white;
            padding: 8px 14px;
            border-radius: 10px;
            font-size: 12px;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            cursor: pointer;
        }

        .btn-secondary {
            background: var(--accent-warm);
        }

        .btn-ghost {
            background: transparent;
            color: var(--ink);
            border: 1px solid var(--grid);
        }

        .timeline {
            min-height: 260px;
        }

        #timelineChart {
            width: 100%;
            height: 260px;
        }

        #chart {
            width: 100%;
            height: 640px;
        }

        .snapshot-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 16px;
        }

        .snapshot-card {
            border: 1px solid var(--grid);
            border-radius: 14px;
            padding: 14px;
            background: #fff;
        }

        .snapshot-card h3 {
            margin: 0 0 8px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--muted);
        }

        .snapshot-metric {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            padding: 6px 0;
            border-bottom: 1px solid #f0e6d8;
        }

        .snapshot-metric:last-child {
            border-bottom: none;
        }

        .snapshot-metric span {
            font-family: var(--mono);
        }

        .trades-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            font-family: var(--mono);
        }

        .trades-table th,
        .trades-table td {
            border-bottom: 1px solid #eee3d4;
            padding: 8px 6px;
            text-align: left;
        }

        .health-bar {
            margin-top: 28px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }

        .health-card {
            background: var(--panel);
            border: 1px solid var(--grid);
            border-radius: 14px;
            padding: 12px 14px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .health-card span {
            font-size: 12px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--muted);
        }

        .health-pill {
            padding: 4px 8px;
            border-radius: 999px;
            font-size: 11px;
            font-family: var(--mono);
            border: 1px solid transparent;
        }

        .health-ok {
            background: rgba(42, 111, 95, 0.15);
            border-color: rgba(42, 111, 95, 0.4);
            color: var(--accent-strong);
        }

        .health-warn {
            background: rgba(212, 106, 59, 0.15);
            border-color: rgba(212, 106, 59, 0.35);
            color: var(--accent-warm-strong);
        }

        .health-off {
            background: rgba(178, 74, 66, 0.15);
            border-color: rgba(178, 74, 66, 0.35);
            color: #7f352f;
        }

        .health-unknown {
            background: rgba(111, 98, 87, 0.15);
            border-color: rgba(111, 98, 87, 0.35);
            color: var(--muted);
        }

        .ladder-box {
            margin-top: 14px;
            padding: 10px 12px;
            border-radius: 12px;
            background: #fff;
            border: 1px dashed var(--grid);
        }

        .ladder-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
            gap: 10px;
        }

        .ladder-card {
            border: 1px solid #eee3d4;
            border-radius: 10px;
            padding: 8px 10px;
            background: #fffaf3;
            font-family: var(--mono);
            font-size: 11px;
        }

        .ladder-title {
            font-size: 11px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--muted);
            margin-bottom: 6px;
        }

        .ladder-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 3px 0;
        }

        .ladder-label {
            width: 18px;
            text-align: right;
            color: var(--muted);
        }

        .ladder-bar-wrap {
            flex: 1;
            height: 8px;
            background: #f2e7d8;
            border-radius: 6px;
            overflow: hidden;
        }

        .ladder-bar {
            height: 100%;
            border-radius: 6px;
        }

        .ladder-side-yes .ladder-bar {
            background: rgba(42, 111, 95, 0.8);
        }

        .ladder-side-no .ladder-bar {
            background: rgba(212, 106, 59, 0.85);
        }

        .ladder-meta {
            min-width: 70px;
            text-align: right;
            color: #3a2f28;
        }

        @media (max-width: 900px) {
            #chart {
                height: 480px;
            }
        }
    </style>
</head>

<body>
    <div class="page">
        <header class="hero">
            <div>
                <h1>Kalshi Ops Console</h1>
                <p>Rolling 24 hour tape for live and shadow parity checks.</p>
            </div>
            <div class="hero-chips">
                <div class="chip">
                    <span class="status-dot" id="liveStatusDot"></span>
                    <strong id="liveStatusText">Live: Unknown</strong>
                </div>
                <div class="chip" id="windowChip" style="min-width: 140px; justify-content: center;">Window: --</div>
                <div class="chip" id="clockChip">Time: --</div>
                <div class="chip">
                    <a href="/output.log" target="_blank">output.log</a>
                </div>
            </div>
        </header>

        <div class="grid">
            <section class="panel timeline">
                <div class="panel-header">
                    <h2>Rolling 24h Activity</h2>
                    <small id="timelineStatus">Waiting for data...</small>
                    <div class="panel-actions">
                        <button class="btn btn-ghost" onclick="updateTimeline()">Refresh</button>
                    </div>
                </div>
                <div id="timelineChart"></div>
            </section>

            <section class="panel">
                <div class="panel-header">
                    <h2>Market Gaps (Today)</h2>
                    <small id="gapStatusToday">Waiting for live status...</small>
                    <div class="panel-actions">
                        <label for="gapWindow" style="font-size: 12px; color: var(--muted);">Recent</label>
                        <select id="gapWindow" class="btn btn-ghost">
                            <option value="900">15m</option>
                            <option value="3600" selected>1h</option>
                            <option value="7200">2h</option>
                            <option value="21600">6h</option>
                            <option value="86400">24h</option>
                        </select>
                        <small id="gapCountToday" style="color: var(--muted);">--</small>
                    </div>
                </div>
                <div id="gapChartToday" style="width: 100%; height: 300px;"></div>
            </section>

            <section class="panel">
                <div class="panel-header">
                    <h2>Market Gaps (Tomorrow)</h2>
                    <small id="gapStatusTomorrow">Waiting for live status...</small>
                    <div class="panel-actions">
                        <small id="gapCountTomorrow" style="color: var(--muted);">--</small>
                    </div>
                </div>
                <div id="gapChartTomorrow" style="width: 100%; height: 300px;"></div>
            </section>

            <section class="panel">
                <div class="panel-header">
                    <h2>Orderbook Ladders</h2>
                    <small>Top-of-book depth snapshots (YES + NO).</small>
                </div>
                <div class="ladder-box">
                    <div class="ladder-title">Today</div>
                    <div id="ladderToday">
                        <small style="color: var(--muted);">Orderbook ladder will appear here.</small>
                    </div>
                </div>
                <div class="ladder-box" style="margin-top: 12px;">
                    <div class="ladder-title">Tomorrow</div>
                    <div id="ladderTomorrow">
                        <small style="color: var(--muted);">Orderbook ladder will appear here.</small>
                    </div>
                </div>
            </section>

            <section class="panel">
                <div class="panel-header">
                    <h2>Market Tape</h2>
                    <div class="panel-actions">
                        <label for="fileSelect" style="font-size: 12px; color: var(--muted);">Market Day</label>
                        <select id="fileSelect" class="btn btn-ghost">
                            <option value="">Loading markets...</option>
                        </select>
                        <button class="btn" onclick="loadData()">Refresh Graph</button>
                    </div>
                    <small id="graphStatus">Waiting...</small>
                </div>
                <div id="chart"></div>
            </section>

            <section class="panel">
                <div class="panel-header">
                    <h2>State Snapshot</h2>
                    <small id="snapshotStatus">Updated on refresh.</small>
                </div>
                <div class="snapshot-grid">
                    <div class="snapshot-card" id="liveSnapshot">
                        <h3>Live Trader</h3>
                        <div class="snapshot-metric">
                            <div>Equity</div><span id="liveEquity">-</span>
                        </div>
                        <div class="snapshot-metric">
                            <div>Trades Today</div><span id="liveTrades">-</span>
                        </div>
                        <div class="snapshot-metric">
                            <div>Daily Budget</div><span id="liveBudget">-</span>
                        </div>
                        <div class="snapshot-metric">
                            <div>Spent Today</div><span id="liveSpent">-</span>
                        </div>
                        <div class="snapshot-metric">
                            <div>Last Update</div><span id="liveHeartbeat">-</span>
                        </div>
                    </div>
                    <div class="snapshot-card">
                        <h3>Shadow Engine</h3>
                        <div class="snapshot-metric">
                            <div>Cash</div><span id="shadowCash">$100.00</span>
                        </div>
                        <div class="snapshot-metric">
                            <div>Positions</div><span id="shadowPositions">-</span>
                        </div>
                        <div class="snapshot-metric">
                            <div>Last Trade</div><span id="shadowTrade">No trades done yet</span>
                        </div>
                        <div class="snapshot-metric">
                            <div>Feed</div><span id="shadowFeed">market_logs</span>
                        </div>
                    </div>
                </div>
            </section>

            <section class="panel">
                <div class="panel-header">
                    <h2>Recent Live Trades</h2>
                    <small id="tradesStatus">Pulling latest trades...</small>
                </div>
                <div style="overflow-x: auto;">
                    <table class="trades-table">
                        <thead>
                            <tr>
                                <th>Time</th>
                                <th>Ticker</th>
                                <th>Action</th>
                                <th>Price</th>
                                <th>Qty</th>
                                <th>Cost</th>
                            </tr>
                        </thead>
                        <tbody id="tradesBody">
                            <tr>
                                <td colspan="6">Loading trades...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </section>
        </div>

        <div class="health-bar">
            <div class="health-card">
                <span>Logger</span>
                <div class="health-pill health-unknown" id="healthLogger">Unknown</div>
            </div>
            <div class="health-card">
                <span>Live Trader</span>
                <div class="health-pill health-unknown" id="healthLive">Unknown</div>
            </div>
            <div class="health-card">
                <span>Shadow</span>
                <div class="health-pill health-unknown" id="healthShadow">Unknown</div>
            </div>
            <div class="health-card">
                <span>Observer</span>
                <div class="health-pill health-unknown" id="healthObserver">Unknown</div>
            </div>
            <div class="health-card">
                <span>Dashboard</span>
                <div class="health-pill health-ok" id="healthDash">Online</div>
            </div>
        </div>
    </div>

    <script>
        const LOG_DIR = 'market_logs/';
        const RECENT_FILES_TO_SCAN = 3;
        let currentFile = '';
        let marketCache = { ticks: [], markets: {}, latestMarketData: {}, lastTick: null };
        let latestOrders = [];
        let latestPositions = {};
        let gapCache = { today: null, tomorrow: null };

        function formatTime(date) {
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }

        function updateClock() {
            const now = new Date();
            document.getElementById('clockChip').innerText = `Time: ${formatTime(now)}`;
        }

        async function updateLiveStatus() {
            try {
                const response = await fetch(`/api/status?t=${Date.now()}`);
                const data = await response.json();
                const dot = document.getElementById('liveStatusDot');
                const text = document.getElementById('liveStatusText');
                const status = (data.status || 'UNKNOWN').toUpperCase();
                text.innerText = `Live: ${status}`;
                dot.className = 'status-dot ' + (
                    status === 'RUNNING' ? 'status-running' :
                        status === 'PAUSED' ? 'status-paused' :
                            status === 'STOPPED' ? 'status-stopped' :
                                ''
                );
                document.getElementById('liveEquity').innerText = data.equity ? `$${data.equity.toFixed(2)}` : '-';
                document.getElementById('liveTrades').innerText = data.trades_today || '0';
                document.getElementById('liveBudget').innerText = data.daily_budget ? `$${data.daily_budget.toFixed(2)}` : '-';
                let spentText = data.spent_today ? `$${data.spent_today.toFixed(2)}` : '$0.00';
                if (data.spent_pct !== undefined) {
                    spentText += ` (${data.spent_pct.toFixed(1)}%)`;
                }
                document.getElementById('liveSpent').innerText = spentText;
                document.getElementById('liveHeartbeat').innerText = data.last_update || '-';

                if (data.window_status) {
                    const winChip = document.getElementById('windowChip');
                    winChip.innerHTML = `<strong>${data.window_status.message}</strong>`;
                    winChip.style.color = data.window_status.color;
                    winChip.style.borderColor = data.window_status.color;
                }

                if (data.active_orders) {
                    latestOrders = data.active_orders || [];
                    latestPositions = data.positions || {};
                    renderGapCharts();
                } else if (marketCache.latestMarketData && Object.keys(marketCache.latestMarketData).length) {
                    renderGapCharts();
                }
            } catch (e) {
                document.getElementById('liveStatusText').innerText = 'Live: Offline';
                console.error(e);
            }
        }

        async function fetchManifest() {
            try {
                const response = await fetch(`${LOG_DIR}manifest.json?t=${Date.now()}`);
                const data = await response.json();
                const select = document.getElementById('fileSelect');
                const saved = select.value;
                select.innerHTML = '';
                const files = data.files.slice().reverse();
                files.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file;
                    option.text = file.replace('market_data_KXHIGHNY-', '').replace('.csv', '');
                    select.appendChild(option);
                });
                if (saved && data.files.includes(saved)) {
                    select.value = saved;
                } else if (files.length) {
                    select.value = files[0];
                }
                if (!currentFile && select.value) {
                    currentFile = select.value;
                    loadData();
                }
            } catch (e) {
                document.getElementById('graphStatus').innerText = 'Manifest unavailable';
            }
        }

        function parseMarketCsv(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) {
                return { markets: {}, tickPoints: [], latestMarketData: {}, lastTick: null };
            }
            const header = parseCsvLine(lines[0]);
            const idx = {};
            header.forEach((h, i) => idx[h.trim()] = i);

            const tickPoints = [];
            const markets = {};
            const latestMarketData = {}; // ticker -> { bid, ask }
            let lastTickMs = null;

            for (let i = 1; i < lines.length; i++) {
                const row = lines[i];
                if (!row) continue;
                const parts = parseCsvLine(row);
                const tsRaw = parts[idx['timestamp']];
                const ticker = parts[idx['market_ticker']];
                if (!tsRaw || !ticker) continue;

                const timestamp = new Date(tsRaw);
                const tsMs = timestamp.getTime();

                const bid = parseFloat(parts[idx['best_yes_bid']] ?? '0');
                const ask = parseFloat(parts[idx['implied_yes_ask']] ?? '100');
                const impliedNoAsk = parseFloat(parts[idx['implied_no_ask']] ?? '100');
                const lastTrade = idx['last_trade_price'] !== undefined ? parseFloat(parts[idx['last_trade_price']]) : null;

                if (!markets[ticker]) {
                    markets[ticker] = { x: [], y: [] };
                }
                markets[ticker].x.push(tsRaw);
                markets[ticker].y.push(impliedNoAsk);
                tickPoints.push({ time: timestamp, ticker });

                latestMarketData[ticker] = { bid, ask, lastTs: tsMs, lastTrade };
                if (!lastTickMs || tsMs > lastTickMs) {
                    lastTickMs = tsMs;
                }
            }
            return { markets, tickPoints, latestMarketData, lastTick: lastTickMs ? new Date(lastTickMs) : null };
        }

        function mergeLatestMarketData(target, incoming) {
            Object.keys(incoming).forEach(ticker => {
                const src = incoming[ticker];
                const cur = target[ticker];
                if (!cur || (src.lastTs && (!cur.lastTs || src.lastTs > cur.lastTs))) {
                    target[ticker] = src;
                }
            });
        }

        async function loadData() {
            const select = document.getElementById('fileSelect');
            const filename = select.value;
            if (!filename) return;
            currentFile = filename;
            document.getElementById('graphStatus').innerText = `Loading ${filename}...`;
            try {
                // 1. Load the primary file
                const response = await fetch(`${LOG_DIR}${filename}?t=${Date.now()}`);
                const text = await response.text();
                const parsed = parseMarketCsv(text);

                let mergedMarketData = { ...parsed.latestMarketData };
                let mergedTicks = [...parsed.tickPoints];
                let mergedMarkets = { ...parsed.markets };

                // 2. Always try to load the LATEST file from manifest to get current quotes
                const manifestResponse = await fetch(`${LOG_DIR}manifest.json?t=${Date.now()}`);
                const manifest = await manifestResponse.json();
                if (manifest.files && manifest.files.length > 0) {
                    const recentFiles = manifest.files.slice(-RECENT_FILES_TO_SCAN);
                    for (const recentFile of recentFiles) {
                        if (recentFile === filename) continue;
                        try {
                            const respRecent = await fetch(`${LOG_DIR}${recentFile}?t=${Date.now()}`);
                            const textRecent = await respRecent.text();
                            const parsedRecent = parseMarketCsv(textRecent);
                            mergeLatestMarketData(mergedMarketData, parsedRecent.latestMarketData);
                        } catch (eRecent) { }
                    }
                }

                marketCache.ticks = mergedTicks;
                marketCache.markets = mergedMarkets;
                marketCache.latestMarketData = mergedMarketData;
                marketCache.lastTick = mergedTicks.length
                    ? mergedTicks[mergedTicks.length - 1].time
                    : null;

                renderMarketChart(mergedMarkets, filename);
                document.getElementById('graphStatus').innerText = `Loaded ${filename} at ${formatTime(new Date())}`;
                updateTimeline();
                updateHealth();
                loadGapMarketData();
            } catch (e) {
                document.getElementById('graphStatus').innerText = 'Error loading CSV';
                console.error(e);
            }
        }

        function renderMarketChart(markets, title) {
            const traces = [];
            const sortedTickers = Object.keys(markets).sort();
            sortedTickers.forEach(ticker => {
                const shortName = ticker.split('-').pop();
                traces.push({
                    x: markets[ticker].x,
                    y: markets[ticker].y,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: shortName,
                    marker: { size: 4 }
                });
            });
            const layout = {
                title: `Implied "No" Price - ${title.replace('market_data_', '').replace('.csv', '')}`,
                xaxis: { title: 'Time' },
                yaxis: { title: 'Price (Cents)', range: [0, 100] },
                hovermode: 'closest',
                showlegend: true,
                plot_bgcolor: '#fffaf3',
                paper_bgcolor: '#fffaf3',
                font: { family: 'Space Grotesk, sans-serif', color: '#1f1c18' }
            };
            Plotly.newPlot('chart', traces, layout, { displayModeBar: false });
        }

        async function fetchTradesCsv() {
            try {
                const response = await fetch(`/download_trades?t=${Date.now()}`);
                if (!response.ok) return [];
                const text = await response.text();
                const lines = text.trim().split('\n');
                if (lines.length < 2) return [];
                const headers = lines[0].split(',');
                const trades = [];
                for (let i = 1; i < lines.length; i++) {
                    const parts = lines[i].split(',');
                    if (parts.length !== headers.length) continue;
                    const row = {};
                    headers.forEach((h, idx) => row[h] = parts[idx]);
                    trades.push(row);
                }
                return trades;
            } catch (e) {
                return [];
            }
        }

        async function loadTrades() {
            try {
                const response = await fetch(`/api/trades?t=${Date.now()}`);
                const trades = await response.json();
                const tbody = document.getElementById('tradesBody');
                tbody.innerHTML = '';
                if (!trades.length) {
                    tbody.innerHTML = '<tr><td colspan="6">No trades yet.</td></tr>';
                    document.getElementById('tradesStatus').innerText = 'No trades yet.';
                    return;
                }
                trades.forEach(t => {
                    const tr = document.createElement('tr');
                    const time = t.timestamp ? t.timestamp.split(' ')[1] : '-';
                    tr.innerHTML = `
                        <td>${time}</td>
                        <td>${t.ticker || '-'}</td>
                        <td>${t.action || '-'}</td>
                        <td>${t.price || '-'}</td>
                        <td>${t.qty || '-'}</td>
                        <td>${t.cost ? `$${parseFloat(t.cost).toFixed(2)}` : '-'}</td>
                    `;
                    tbody.appendChild(tr);
                });
                document.getElementById('tradesStatus').innerText = `Updated ${formatTime(new Date())}`;
            } catch (e) {
                document.getElementById('tradesStatus').innerText = 'Trades unavailable';
            }
        }

        async function updateShadowSnapshot() {
            try {
                const response = await fetch(`/unified_engine_out/unified_positions.json?t=${Date.now()}`);
                if (!response.ok) throw new Error('missing');
                const data = await response.json();
                const positions = data.positions ? Object.keys(data.positions).length : 0;
                document.getElementById('shadowCash').innerText = data.cash ? `$${data.cash.toFixed(2)}` : '-';
                document.getElementById('shadowPositions').innerText = positions.toString();
                document.getElementById('shadowTrade').innerText = 'See trades file';
            } catch (e) {
                document.getElementById('shadowCash').innerText = '$100.00 (default)';
                document.getElementById('shadowPositions').innerText = '0';
                document.getElementById('shadowTrade').innerText = 'No trades done yet';
            }
        }

        async function updateTimeline() {
            const now = new Date();
            const start = new Date(now.getTime() - 24 * 60 * 60 * 1000);

            const marketPoints = [];
            if (marketCache.ticks.length) {
                const minuteBuckets = new Set();
                marketCache.ticks.forEach(tick => {
                    if (tick.time < start || tick.time > now) return;
                    const minuteKey = tick.time.toISOString().slice(0, 16);
                    if (!minuteBuckets.has(minuteKey)) {
                        minuteBuckets.add(minuteKey);
                        marketPoints.push(new Date(minuteKey));
                    }
                });
            }

            const liveTrades = await fetchTradesCsv();
            const livePoints = liveTrades
                .map(t => new Date(t.timestamp))
                .filter(t => !isNaN(t) && t >= start && t <= now);

            let shadowPoints = [];
            try {
                const response = await fetch(`/unified_engine_out/unified_trades.csv?t=${Date.now()}`);
                if (response.ok) {
                    const text = await response.text();
                    const lines = text.trim().split('\n');
                    shadowPoints = lines.slice(1).map(row => new Date(row.split(',')[0]));
                    shadowPoints = shadowPoints.filter(t => !isNaN(t) && t >= start && t <= now);
                }
            } catch (e) {
                shadowPoints = [];
            }

            const traces = [
                {
                    x: marketPoints,
                    y: marketPoints.map(() => 'Market ticks'),
                    mode: 'markers',
                    type: 'scatter',
                    name: 'Market ticks',
                    marker: { size: 6, color: '#2a6f5f' }
                },
                {
                    x: livePoints,
                    y: livePoints.map(() => 'Live trades'),
                    mode: 'markers',
                    type: 'scatter',
                    name: 'Live trades',
                    marker: { size: 8, color: '#d46a3b' }
                },
                {
                    x: shadowPoints,
                    y: shadowPoints.map(() => 'Shadow trades'),
                    mode: 'markers',
                    type: 'scatter',
                    name: 'Shadow trades',
                    marker: { size: 8, color: '#1d5749' }
                }
            ];

            const layout = {
                xaxis: {
                    range: [start, now],
                    title: 'Time',
                    gridcolor: '#efe3d4'
                },
                yaxis: {
                    type: 'category',
                    categoryorder: 'array',
                    categoryarray: ['Market ticks', 'Live trades', 'Shadow trades']
                },
                plot_bgcolor: '#fffaf3',
                paper_bgcolor: '#fffaf3',
                margin: { l: 90, r: 20, t: 10, b: 40 },
                font: { family: 'IBM Plex Mono, monospace', color: '#1f1c18', size: 11 },
                showlegend: false
            };

            Plotly.newPlot('timelineChart', traces, layout, { displayModeBar: false });
            document.getElementById('timelineStatus').innerText = `Updated ${formatTime(new Date())}`;
        }

        function setHealth(id, status) {
            const el = document.getElementById(id);
            if (!status || !status.state) {
                el.innerText = 'Unknown';
                el.className = 'health-pill health-unknown';
                return;
            }
            const age = status.age_s !== null ? ` (${Math.round(status.age_s)}s)` : '';
            if (status.state === 'ok') {
                el.innerText = `Active${age}`;
                el.className = 'health-pill health-ok';
            } else if (status.state === 'stale') {
                el.innerText = `Stale${age}`;
                el.className = 'health-pill health-warn';
            } else if (status.state === 'missing') {
                el.innerText = 'Missing';
                el.className = 'health-pill health-off';
            } else {
                el.innerText = 'Unknown';
                el.className = 'health-pill health-unknown';
            }
        }

        function updateHealth() {
            fetch(`/api/health?t=${Date.now()}&max_age_s=30`)
                .then(r => r.ok ? r.json() : null)
                .then(data => {
                    if (!data || !data.checks) {
                        setHealth('healthLogger', null);
                        setHealth('healthLive', null);
                        setHealth('healthShadow', null);
                        setHealth('healthObserver', null);
                        return;
                    }
                    setHealth('healthLogger', data.checks.logger);
                    setHealth('healthLive', data.checks.live_trader);
                    setHealth('healthShadow', data.checks.shadow);
                    setHealth('healthObserver', data.checks.observer);
                })
                .catch(() => {
                    setHealth('healthLogger', null);
                    setHealth('healthLive', null);
                    setHealth('healthShadow', null);
                    setHealth('healthObserver', null);
                });
        }

        document.getElementById('fileSelect').addEventListener('change', (e) => {
            currentFile = e.target.value;
            loadData();
        });
        const gapWindow = document.getElementById('gapWindow');
        if (gapWindow) {
            gapWindow.addEventListener('change', () => renderGapCharts());
        }

        fetchManifest();
        updateClock();
        updateLiveStatus();
        loadTrades();
        updateShadowSnapshot();
        updateTimeline();
        loadGapMarketData();

        setInterval(fetchManifest, 10000);
        setInterval(loadData, 30000);
        setInterval(updateLiveStatus, 2500);
        setInterval(loadTrades, 6000);
        setInterval(updateClock, 1000);
        setInterval(updateTimeline, 60000);
            setInterval(updateShadowSnapshot, 45000);
        setInterval(updateHealth, 15000);
        setInterval(loadGapMarketData, 60000);
        function formatMarketDateCode(date) {
            const months = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
            const yy = String(date.getFullYear()).slice(-2);
            const dd = String(date.getDate()).padStart(2, '0');
            return `${yy}${months[date.getMonth()]}${dd}`;
        }

        function parseMarketDateCode(code) {
            if (!code || code.length !== 7) return null;
            const months = { JAN: 0, FEB: 1, MAR: 2, APR: 3, MAY: 4, JUN: 5, JUL: 6, AUG: 7, SEP: 8, OCT: 9, NOV: 10, DEC: 11 };
            const yy = parseInt(code.slice(0, 2), 10);
            const mon = months[code.slice(2, 5)];
            const dd = parseInt(code.slice(5, 7), 10);
            if (Number.isNaN(yy) || mon === undefined || Number.isNaN(dd)) return null;
            return new Date(2000 + yy, mon, dd);
        }

        function ymdInTz(date, tz) {
            return new Intl.DateTimeFormat('en-CA', {
                timeZone: tz,
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            }).format(date);
        }

        function codeToYmd(code) {
            const date = parseMarketDateCode(code);
            if (!date) return null;
            const yyyy = date.getFullYear();
            const mm = String(date.getMonth() + 1).padStart(2, '0');
            const dd = String(date.getDate()).padStart(2, '0');
            return `${yyyy}-${mm}-${dd}`;
        }

        function parseCsvLine(line) {
            const out = [];
            let cur = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const ch = line[i];
                if (ch === '"' ) {
                    if (inQuotes && line[i + 1] === '"') {
                        cur += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (ch === ',' && !inQuotes) {
                    out.push(cur);
                    cur = '';
                } else {
                    cur += ch;
                }
            }
            out.push(cur);
            return out;
        }

        function parseLadderCsv(text) {
            const lines = text.trim().split('\n');
            if (lines.length < 2) return {};
            const header = parseCsvLine(lines[0]);
            const idx = {};
            header.forEach((h, i) => idx[h.trim()] = i);
            const latest = {};
            for (let i = 1; i < lines.length; i++) {
                const row = lines[i];
                if (!row) continue;
                const parts = parseCsvLine(row);
                const ticker = parts[idx['market_ticker']] || '';
                if (!ticker) continue;
                const ts = parts[idx['timestamp']] || '';
                const yesRaw = parts[idx['yes_bids']] || '[]';
                const noRaw = parts[idx['no_bids']] || '[]';
                try {
                    const yes = JSON.parse(yesRaw);
                    const no = JSON.parse(noRaw);
                    if (!latest[ticker] || (ts && ts > latest[ticker].timestamp)) {
                        latest[ticker] = { timestamp: ts, yes, no };
                    }
                } catch (e) {
                    continue;
                }
            }
            return latest;
        }

        async function fetchLadderFile(filename) {
            if (!filename) return null;
            const ladderFile = filename.replace('market_data_', 'orderbook_ladder_');
            try {
                const resp = await fetch(`${LOG_DIR}${ladderFile}?t=${Date.now()}`);
                if (!resp.ok) return null;
                const text = await resp.text();
                return parseLadderCsv(text);
            } catch (e) {
                return null;
            }
        }

        async function loadGapMarketData() {
            try {
                const response = await fetch(`${LOG_DIR}manifest.json?t=${Date.now()}`);
                const data = await response.json();
                const files = data.files || [];
                if (!files.length) return;

                const tz = 'America/New_York';
                const todayYmd = ymdInTz(new Date(), tz);
                const tomorrowDate = new Date();
                tomorrowDate.setDate(tomorrowDate.getDate() + 1);
                const tomorrowYmd = ymdInTz(tomorrowDate, tz);

                const latestFile = files[files.length - 1] || null;
                const prevFile = files.length > 1 ? files[files.length - 2] : null;

                const latestCode = latestFile ? (latestFile.match(/-(\d{2}[A-Z]{3}\d{2})\.csv$/) || [])[1] : null;
                const prevCode = prevFile ? (prevFile.match(/-(\d{2}[A-Z]{3}\d{2})\.csv$/) || [])[1] : null;
                const latestYmd = codeToYmd(latestCode);
                const prevYmd = codeToYmd(prevCode);

                let todayFile = latestFile;
                let tomorrowFile = prevFile;

                if (latestYmd && latestYmd > todayYmd) {
                    // Latest file is for tomorrow or later.
                    todayFile = prevFile;
                    tomorrowFile = latestFile;
                } else if (latestYmd && latestYmd === todayYmd) {
                    todayFile = latestFile;
                    tomorrowFile = prevFile;
                } else if (prevYmd && prevYmd === todayYmd && latestYmd && latestYmd < todayYmd) {
                    todayFile = prevFile;
                    tomorrowFile = latestFile;
                }

                async function fetchMarketFile(filename) {
                    if (!filename) return null;
                    const resp = await fetch(`${LOG_DIR}${filename}?t=${Date.now()}`);
                    const text = await resp.text();
                    const parsed = parseMarketCsv(text);
                    const ladder = await fetchLadderFile(filename);
                    return { file: filename, marketData: parsed.latestMarketData, lastTick: parsed.lastTick, ladder };
                }

                gapCache.today = await fetchMarketFile(todayFile);
                gapCache.tomorrow = await fetchMarketFile(tomorrowFile);
                renderGapCharts();
            } catch (e) {
                // Ignore gap refresh errors
            }
        }

        function renderGapCharts() {
            const gapWindow = document.getElementById('gapWindow');
            const recentWindowMs = gapWindow ? parseInt(gapWindow.value, 10) * 1000 : 3600 * 1000;

            const todayData = gapCache.today;
            const tomorrowData = gapCache.tomorrow;

            renderGapChartTo({
                chartId: 'gapChartToday',
                statusId: 'gapStatusToday',
                countId: 'gapCountToday',
                orders: latestOrders,
                positions: latestPositions,
                marketDataOverride: todayData ? todayData.marketData : null,
                ladderData: todayData ? todayData.ladder : null,
                fileLabel: todayData ? todayData.file : null,
                recentWindowMs,
                includeAll: true,
                ladderTarget: 'ladderToday'
            });

            renderGapChartTo({
                chartId: 'gapChartTomorrow',
                statusId: 'gapStatusTomorrow',
                countId: 'gapCountTomorrow',
                orders: latestOrders,
                positions: latestPositions,
                marketDataOverride: tomorrowData ? tomorrowData.marketData : null,
                ladderData: tomorrowData ? tomorrowData.ladder : null,
                fileLabel: tomorrowData ? tomorrowData.file : null,
                recentWindowMs,
                includeAll: true,
                ladderTarget: 'ladderTomorrow'
            });
        }

        function renderGapChartTo(opts) {
            const chartId = opts.chartId;
            const statusId = opts.statusId;
            const countId = opts.countId;
            const orders = opts.orders || [];
            const positions = opts.positions || {};
            const marketDataOverride = opts.marketDataOverride || null;
            const ladderData = opts.ladderData || null;
            const fileLabel = opts.fileLabel || null;
            const recentWindowMs = opts.recentWindowMs || 3600 * 1000;
            const includeAll = !!opts.includeAll;
            const ladderTarget = opts.ladderTarget || null;

            const nowMs = Date.now();
            // 1. Collect tickers from the selected file only
            const allTickers = new Set();
            if (marketDataOverride) {
                Object.keys(marketDataOverride).forEach(t => allTickers.add(t));
            } else if (window.marketCache && window.marketCache.latestMarketData) {
                Object.keys(window.marketCache.latestMarketData).forEach(t => allTickers.add(t));
            }

            const marketData = {};

            // Initialize all
            allTickers.forEach(ticker => {
                // Default to market data if available
                const m = marketDataOverride
                    ? marketDataOverride[ticker]
                    : ((window.marketCache && window.marketCache.latestMarketData) ? window.marketCache.latestMarketData[ticker] : null);
                marketData[ticker] = {
                    bid: m ? m.bid : 0,
                    ask: m ? m.ask : 100,
                    hasMarketData: !!m,
                    lastTs: m ? m.lastTs : null,
                    lastTrade: m ? m.lastTrade : null,
                    bidQty: 0,
                    askQty: 0,
                    yesPos: 0,
                    noPos: 0,
                    userBid: null,
                    userAsk: null
                };
            });

            // 2. Process User Orders (Overlay) - only if present in this file
            orders.forEach(o => {
                if (!marketData[o.ticker]) return;
                if (o.action === 'BUY_YES') {
                    if (marketData[o.ticker].userBid === null || o.price > marketData[o.ticker].userBid) {
                        marketData[o.ticker].userBid = o.price;
                        marketData[o.ticker].bidQty = o.qty;
                    }
                } else if (o.action === 'BUY_NO') {
                    if (marketData[o.ticker].userAsk === null || o.price < marketData[o.ticker].userAsk) {
                        marketData[o.ticker].userAsk = o.price;
                        marketData[o.ticker].askQty = o.qty;
                    }
                }
            });

            // 3. Process Positions (only if present in this file)
            if (positions) {
                Object.keys(positions).forEach(ticker => {
                    if (!marketData[ticker]) return;
                    const p = positions[ticker];
                    marketData[ticker].yesPos = p.yes || 0;
                    marketData[ticker].noPos = p.no || 0;
                });
            }

            // Prepare traces
            const tickers = Array.from(allTickers);

            // Numerical Sort: B strikes then T strikes
            const getStrike = t => {
                const m = t.match(/(\d+(\.\d+)?)$/);
                if (!m) return 0;
                return parseFloat(m[1]);
            };
            const getSide = t => {
                const m = t.match(/([BT])\d+(\.\d+)?$/);
                return m ? m[1] : '';
            };
            tickers.sort((a, b) => {
                const sa = getStrike(a);
                const sb = getStrike(b);
                if (sa !== sb) return sa - sb;
                const sideOrder = { B: 0, T: 1 };
                return (sideOrder[getSide(a)] ?? 0) - (sideOrder[getSide(b)] ?? 0);
            });

            const x = [];
            const y = []; // Gap Size (Height of bar)
            const text = [];
            const annotations = [];
            const barColors = [];
            let filteredCount = 0;

            tickers.forEach(ticker => {
                const data = marketData[ticker];
                const lastTsMs = data.lastTs || null;
                const isRecent = lastTsMs ? (nowMs - lastTsMs) <= recentWindowMs : false;
                const hasInterest = (data.userBid !== null || data.userAsk !== null || data.yesPos || data.noPos);
                if (includeAll) {
                    // include all tickers from the file
                } else if (!isRecent && !hasInterest) {
                    return;
                }
                filteredCount += 1;
                const shortName = ticker.split('-').pop();

                // Calculate Market Gap
                const bid = data.bid;
                const ask = data.ask;
                const gap = ask - bid;

                x.push(shortName);
                y.push(gap);

                // Color based on Gap
                if (!data.hasMarketData) barColors.push('rgba(200, 200, 200, 0.3)'); // Grey for no data
                else if (!isRecent) barColors.push('rgba(160, 160, 160, 0.4)'); // Stale data
                else if (gap <= 2) barColors.push('#10B981'); // Tight
                else if (gap <= 10) barColors.push('#F59E0B'); // Medium
                else barColors.push('#EF4444'); // Wide

                // Bar Text (unused - we use annotations instead)
                text.push("");

                // Order annotations (above/below the centered bar)
                if (data.userBid !== null) {
                    annotations.push({
                        x: shortName,
                        y: (gap / 2) + 0.8,
                        text: `Buy ${data.bidQty}@${data.userBid}c`,
                        showarrow: false,
                        font: { color: '#1d4ed8', size: 11, weight: 'bold' }
                    });
                }
                if (data.userAsk !== null) {
                    const yesAsk = 100 - data.userAsk;
                    annotations.push({
                        x: shortName,
                        y: -(gap / 2) - 0.9,
                        text: `Sell ${data.askQty}@${yesAsk}c`,
                        showarrow: false,
                        font: { color: '#a21caf', size: 11, weight: 'bold' }
                    });
                }

                // Gap label (inside bar, above centerline)
                if (data.hasMarketData) {
                    annotations.push({
                        x: shortName,
                        y: Math.max(-gap / 2 + 0.2, (gap / 2) - 0.3),
                        text: `${gap}c`,
                        showarrow: false,
                        font: { color: '#1f1c18', size: 11, weight: 'bold' }
                    });
                }

                // Holdings annotation (inside bar, below centerline)
                if (data.yesPos || data.noPos) {
                    annotations.push({
                        x: shortName,
                        y: Math.min(gap / 2 - 0.2, -(gap / 2) + 0.3),
                        text: `Y:${data.yesPos} N:${data.noPos}`,
                        showarrow: false,
                        font: { color: '#1f1c18', size: 9, weight: 'bold' }
                    });
                }
            });

            const trace = {
                x: x,
                y: y,
                base: y.map(val => -val / 2),
                type: 'bar',
                text: text,
                textposition: 'none',
                marker: {
                    color: barColors,
                    line: { color: '#1f1c18', width: 1 }
                },
                hoverinfo: 'text',
                hovertext: x.map((t, i) => {
                    const d = marketData[tickers[i]];
                    const yesAsk = d.userAsk !== null ? (100 - d.userAsk) : null;
                    const lastUpdated = d.lastTs ? formatTime(new Date(d.lastTs)) : '-';
                    return `${t}<br>Gap: ${y[i]}c<br>Market Bid: ${d.bid}c<br>Market Ask: ${d.ask}c<br>Our Bid: ${d.userBid ?? '-'}c<br>Our Ask (YES eq): ${yesAsk ?? '-'}c<br>Hold Y:${d.yesPos} N:${d.noPos}<br>Last: ${lastUpdated}`;
                })
            };

            const traces = [trace];

            const maxGap = y.length ? Math.max(...y) : 0;
            const gapCeil = Math.max(4, Math.ceil((maxGap / 2) + 2));
            const layout = {
                xaxis: { title: 'Market' },
                yaxis: { title: 'Gap (Cents)', range: [-gapCeil, gapCeil], zeroline: true, zerolinecolor: '#1f1c18' },
                annotations: annotations,
                plot_bgcolor: '#fffaf3',
                paper_bgcolor: '#fffaf3',
                margin: { t: 50, b: 60, l: 40, r: 20 },
                font: { family: 'Space Grotesk, sans-serif', color: '#1f1c18' },
                showlegend: false
            };

            const gapStatus = document.getElementById(statusId);
            if (gapStatus) {
                const gapWindow = document.getElementById('gapWindow');
                const windowLabel = gapWindow ? gapWindow.options[gapWindow.selectedIndex].text : '1h';
                const fileText = fileLabel ? fileLabel.replace('market_data_', '').replace('.csv', '') : 'no file';
                gapStatus.innerText = `Showing ${filteredCount} markets (last ${windowLabel}) · ${fileText}`;
            }
            const gapCount = document.getElementById(countId);
            if (gapCount) {
                gapCount.innerText = `${filteredCount} markets`;
            }
            Plotly.newPlot(chartId, traces, layout, { displayModeBar: false });

            if (ladderTarget) {
                renderLadderBox(ladderTarget, tickers, ladderData);
            }
        }

        function renderLadderBox(containerId, tickers, ladderData) {
            const container = document.getElementById(containerId);
            if (!container) return;
            if (!ladderData) {
                container.innerHTML = '<small style="color: var(--muted);">No ladder data found.</small>';
                return;
            }
            const cards = [];
            tickers.forEach(ticker => {
                const ladder = ladderData[ticker];
                if (!ladder) return;
                const shortName = ticker.split('-').pop();
                const yesLevels = Array.isArray(ladder.yes) ? ladder.yes.slice(0, 5) : [];
                const noLevels = Array.isArray(ladder.no) ? ladder.no.slice(0, 5) : [];
                const maxQty = Math.max(
                    1,
                    ...yesLevels.map(l => l[1] || 0),
                    ...noLevels.map(l => l[1] || 0)
                );

                const rows = [];
                yesLevels.forEach((lvl, idx) => {
                    const price = lvl[0];
                    const qty = lvl[1];
                    const width = Math.min(100, (qty / maxQty) * 100);
                    rows.push(`
                        <div class="ladder-row ladder-side-yes">
                            <div class="ladder-label">Y${idx + 1}</div>
                            <div class="ladder-bar-wrap">
                                <div class="ladder-bar" style="width:${width}%"></div>
                            </div>
                            <div class="ladder-meta">${price}c · ${qty}</div>
                        </div>
                    `);
                });
                noLevels.forEach((lvl, idx) => {
                    const price = lvl[0];
                    const qty = lvl[1];
                    const width = Math.min(100, (qty / maxQty) * 100);
                    rows.push(`
                        <div class="ladder-row ladder-side-no">
                            <div class="ladder-label">N${idx + 1}</div>
                            <div class="ladder-bar-wrap">
                                <div class="ladder-bar" style="width:${width}%"></div>
                            </div>
                            <div class="ladder-meta">${price}c · ${qty}</div>
                        </div>
                    `);
                });

                cards.push(`
                    <div class="ladder-card">
                        <div class="ladder-title">${shortName}</div>
                        ${rows.join('')}
                    </div>
                `);
            });
            if (!cards.length) {
                container.innerHTML = '<small style="color: var(--muted);">No ladder data available for these markets.</small>';
                return;
            }
            container.innerHTML = `<div class="ladder-grid">${cards.join('')}</div>`;
        }




    </script>
</body>

</html>
